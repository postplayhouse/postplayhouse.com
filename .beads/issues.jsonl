{"id":"postplayhouse.com-04o","title":"TypeError: Load failed (network fetch failure)","description":"**Sentry Issues:** JAVASCRIPT-SVELTEKIT-A2, JAVASCRIPT-SVELTEKIT-9V\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-A2\n**Occurrences:** Multiple\n\n**Error:** TypeError: Load failed (postplayhouse.com)\n**Affected pages:** /(app), /(app)/ticket-info\n**File:** src/routes/(app)/+page.ts, src/routes/(app)/ticket-info/+page.ts\n\n**Likely Cause:** Network fetch operations failing during page load. Could be due to:\n- User network interruption\n- API endpoint temporarily unavailable\n- Request timeout\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-21T22:54:18.211791-05:00","updated_at":"2025-12-21T23:01:27.951456-05:00","closed_at":"2025-12-21T23:01:27.951456-05:00","close_reason":"Network connectivity issue on user's end - not a code bug","labels":["bug"]}
{"id":"postplayhouse.com-0za","title":"Export and cleanup","description":"Create export endpoint for YAML generation. Document end-of-season archival workflow. Remove or deprecate old GitHub PR code.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-22T00:06:00.378184-05:00","updated_at":"2025-12-22T00:06:00.378184-05:00","dependencies":[{"issue_id":"postplayhouse.com-0za","depends_on_id":"postplayhouse.com-wb6","type":"parent-child","created_at":"2025-12-22T00:06:18.284577-05:00","created_by":"daemon"},{"issue_id":"postplayhouse.com-0za","depends_on_id":"postplayhouse.com-pb0","type":"blocks","created_at":"2025-12-22T00:06:24.244131-05:00","created_by":"daemon"},{"issue_id":"postplayhouse.com-0za","depends_on_id":"postplayhouse.com-cr8","type":"blocks","created_at":"2026-01-11T00:32:33.153829-05:00","created_by":"dondenton"}]}
{"id":"postplayhouse.com-2ef","title":"DevalueError: Cannot stringify arbitrary non-POJOs","description":"**Sentry Issue:** JAVASCRIPT-SVELTEKIT-A1\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-A1\n**Occurrences:** 1\n**First Seen:** 2025-12-09\n\n**Error:** DevalueError: Cannot stringify arbitrary non-POJOs\n**Culprit:** GET /(app) - during prerender of getMediaImages\n\n**Stacktrace:** Error in devalue stringify when trying to serialize data from /\\_app/remote/prqesa/getMediaImages endpoint.\n\n**Likely Cause:** The getMediaImages endpoint returns data that contains non-serializable objects (like class instances, functions, or complex objects). Data passed to SvelteKit must be plain JSON-serializable objects.\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-21T22:54:15.042385-05:00","updated_at":"2025-12-21T23:00:50.275184-05:00","closed_at":"2025-12-21T23:00:50.275184-05:00","close_reason":"Fixed by refactoring media page to use enhanced:img (commits after Dec 9)","labels":["bug"]}
{"id":"postplayhouse.com-395","title":"TypeError: Cannot read properties of undefined (reading 'sources')","description":"**Sentry Issue:** JAVASCRIPT-SVELTEKIT-A0\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-A0\n**Occurrences:** Multiple\n**First Seen:** 2025-12-09\n\n**Error:** TypeError: Cannot read properties of undefined (reading 'sources')\n**Culprit:** GET /(app)/media\n\n**Likely Cause:** The media page loader is accessing .sources property on an undefined object. Check the data loading logic for the media page.\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-21T22:54:14.478813-05:00","updated_at":"2025-12-21T23:00:50.726196-05:00","closed_at":"2025-12-21T23:00:50.726196-05:00","close_reason":"Fixed by refactoring media page - no longer accesses .sources directly (commits after Dec 9)","labels":["bug"]}
{"id":"postplayhouse.com-3it","title":"CustomEvent: unhandled promise rejection","description":"**Sentry Issue:** JAVASCRIPT-SVELTEKIT-7Q\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-7Q\n**Occurrences:** Multiple\n**First Seen:** 2024\n\n**Error:** Event CustomEvent (type=unhandledrejection) captured as promise rejection\n**Affected pages:** /(app)/productions/[year], /(app)/jobs\n\n**Likely Cause:** An async operation is failing and the promise rejection is not being caught. Check for missing try/catch blocks or .catch() handlers on promises in the productions and jobs pages.\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-21T22:54:16.950017-05:00","updated_at":"2025-12-21T23:01:55.397521-05:00","closed_at":"2025-12-21T23:01:55.397521-05:00","close_reason":"No stacktrace available - likely browser extension or third-party script. 15 occurrences over 11 months, not reproducible.","labels":["bug"]}
{"id":"postplayhouse.com-502","title":"TypeError: Failed to fetch dynamically imported module","description":"**Sentry Issue:** JAVASCRIPT-SVELTEKIT-S\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-S\n**Occurrences:** Multiple\n**First Seen:** 2024 (ongoing)\n\n**Error:** TypeError: Failed to fetch dynamically imported module (various node files)\n**Affected pages:** /, /jobs, /ratings/, /productions/*, /calendar/*\n\n**Likely Cause:** Dynamic module fetching fails when:\n- Deployment changes chunk hashes but user has cached HTML\n- Network issues during lazy loading\n- Browser extensions blocking requests\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-21T22:54:13.923511-05:00","updated_at":"2025-12-21T23:01:28.875786-05:00","closed_at":"2025-12-21T23:01:28.875786-05:00","close_reason":"Dynamic import cache issue - same as JAVASCRIPT-SVELTEKIT-T, happens when cached JS becomes stale after deployments","labels":["bug"]}
{"id":"postplayhouse.com-5p9","title":"New submission flow","description":"Create /api/bio-submission/submit/+server.ts using Blobs. Upload original images to B2 originals/ folder. Update frontend form to use new endpoint.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T00:05:59.516398-05:00","updated_at":"2025-12-23T00:01:35.527932-05:00","closed_at":"2025-12-23T00:01:35.527932-05:00","close_reason":"Implemented new bio submission flow: created /api/bio-submission/submit endpoint using Netlify Blobs for metadata storage, B2 for original image uploads, and updated frontend form to use new endpoint instead of GitHub PR flow","dependencies":[{"issue_id":"postplayhouse.com-5p9","depends_on_id":"postplayhouse.com-wb6","type":"parent-child","created_at":"2025-12-22T00:06:17.737553-05:00","created_by":"daemon"},{"issue_id":"postplayhouse.com-5p9","depends_on_id":"postplayhouse.com-v1t","type":"blocks","created_at":"2025-12-22T00:06:23.692877-05:00","created_by":"daemon"}]}
{"id":"postplayhouse.com-6r0","title":"SSR data endpoint","description":"Create /api/people/[year].json/+server.ts that merges YAML data with approved bios from Blobs. Add cache headers with tags for CDN purging.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T00:05:58.651488-05:00","updated_at":"2025-12-22T23:22:01.229564-05:00","closed_at":"2025-12-22T23:22:01.229564-05:00","close_reason":"Created /api/people/[year].json SSR endpoint that merges YAML data with approved bios from Netlify Blobs for current season. Includes cache headers with tags for CDN purging.","dependencies":[{"issue_id":"postplayhouse.com-6r0","depends_on_id":"postplayhouse.com-wb6","type":"parent-child","created_at":"2025-12-22T00:06:17.180128-05:00","created_by":"daemon"},{"issue_id":"postplayhouse.com-6r0","depends_on_id":"postplayhouse.com-f0u","type":"blocks","created_at":"2025-12-22T00:06:23.089508-05:00","created_by":"daemon"}]}
{"id":"postplayhouse.com-8a0","title":"Create admin image proxy endpoint","description":"## Goal\nCreate an API endpoint that allows the admin UI to display pending bio images from B2 storage or the local filesystem.\n\n## Background\nPending bio submissions store images in two possible locations:\n1. **B2 Storage**: New uploads stored at paths like `originals/2026/john-doe.jpg`\n2. **Local Filesystem**: Old headshots referenced by paths like `src/images/people/2025/john-doe.jpg`\n\nThe admin UI needs to display these images, but:\n- B2 images are in private storage requiring authentication\n- The browser cannot directly access server filesystem paths\n\nThis proxy endpoint fetches images server-side and returns them to the browser.\n\n## Implementation\n\n### Create `src/routes/api/admin/image/[...path]/+server.ts`\n\n```typescript\nimport { error } from \"@sveltejs/kit\"\nimport { individualPassphraseDetails, isAdmin } from \"$routes/api/bio-submission/passphraseHelpers\"\nimport { downloadFromB2 } from \"$lib/server/b2\"\nimport * as fs from \"node:fs/promises\"\nimport * as path from \"node:path\"\n\nexport const GET = async ({ request, params }) =\u003e {\n  // Validate admin access\n  const { correct, position } = individualPassphraseDetails(request)\n  if (!correct || !isAdmin(position)) {\n    return error(403, { message: \"Admin access required\" })\n  }\n\n  const imagePath = params.path\n  if (!imagePath) {\n    return error(400, { message: \"Image path required\" })\n  }\n\n  let imageBuffer: Buffer\n  let contentType = \"image/jpeg\"\n\n  try {\n    if (imagePath.startsWith(\"src/images/\")) {\n      // Local filesystem image (old headshot)\n      const fullPath = path.join(process.cwd(), imagePath)\n      \n      // Security: ensure path doesn't escape the images directory\n      const normalizedPath = path.normalize(fullPath)\n      if (!normalizedPath.startsWith(path.join(process.cwd(), \"src/images/\"))) {\n        return error(403, { message: \"Invalid image path\" })\n      }\n      \n      imageBuffer = await fs.readFile(fullPath)\n      \n      // Determine content type from extension\n      const ext = path.extname(imagePath).toLowerCase()\n      if (ext === \".png\") contentType = \"image/png\"\n      else if (ext === \".gif\") contentType = \"image/gif\"\n      else if (ext === \".webp\") contentType = \"image/webp\"\n    } else {\n      // B2 storage image\n      imageBuffer = await downloadFromB2(imagePath)\n      \n      // Determine content type from extension\n      const ext = path.extname(imagePath).toLowerCase()\n      if (ext === \".png\") contentType = \"image/png\"\n      else if (ext === \".gif\") contentType = \"image/gif\"\n      else if (ext === \".webp\") contentType = \"image/webp\"\n    }\n  } catch (err) {\n    console.error(\"Failed to fetch image:\", imagePath, err)\n    return error(404, { message: \"Image not found\" })\n  }\n\n  return new Response(imageBuffer, {\n    headers: {\n      \"Content-Type\": contentType,\n      \"Cache-Control\": \"private, max-age=3600\",\n    },\n  })\n}\n```\n\n## Security Considerations\n1. **Admin authentication required** - validates passphrase and admin position\n2. **Path traversal prevention** - normalizes and validates local paths stay within src/images/\n3. **Private cache headers** - prevents CDN caching of admin-only content\n\n## Dependencies\n- `src/lib/server/b2.ts` - downloadFromB2 function\n- `src/routes/api/bio-submission/passphraseHelpers.ts` - admin authentication\n\n## Usage in Admin UI\n```typescript\n// In admin page component\nconst imageUrl = \\`/api/admin/image/\\${encodeURIComponent(bio.originalImageUrl)}\\`\n\n// Include auth header\nconst response = await fetch(imageUrl, {\n  headers: { Authorization: sanitizedPassphrase(passphrase) }\n})\n```\n\nOr use an img tag with auth handled via query param or cookie (simpler):\n```svelte\n\u003cimg src=\"/api/admin/image/{encodeURIComponent(bio.originalImageUrl)}?auth={passphrase}\" /\u003e\n```\n\nNote: For img tags, may need to add query param auth support to the endpoint.\n\n## Verification\n1. Start dev server: `pnpm dev`\n2. Submit a bio with a new image at /bio-submission/\n3. Using curl or browser dev tools, test the endpoint:\n   ```bash\n   curl -H \"Authorization: admin_passphrase\" http://localhost:5173/api/admin/image/originals/2026/test.jpg\n   ```\n4. Verify image is returned with correct content type\n5. Verify 403 is returned without valid admin passphrase","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T00:21:45.226658-05:00","created_by":"dondenton","updated_at":"2026-01-11T00:21:45.226658-05:00","dependencies":[{"issue_id":"postplayhouse.com-8a0","depends_on_id":"postplayhouse.com-chd","type":"blocks","created_at":"2026-01-11T00:30:54.417683-05:00","created_by":"dondenton"}]}
{"id":"postplayhouse.com-8db","title":"SyntaxError: Unexpected token - not found is not valid JSON","description":"**Sentry Issue:** JAVASCRIPT-SVELTEKIT-A4\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-A4\n**Occurrences:** 1\n**First Seen:** 2025-12-15\n\n**Error:** SyntaxError: Unexpected token 'o', \"not found\" is not valid JSON\n**Culprit:** GET /(app)/plan-your-visit\n**File:** src/routes/(app)/plan-your-visit/+page.ts:5\n\n**Stacktrace shows:** The load function calls res.json() on a response that contains the text \"not found\" instead of valid JSON.\n\n**Likely Cause:** An API endpoint is returning a 404 or error response with plain text \"not found\" instead of JSON. The plan-your-visit page tries to parse this as JSON.\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-21T22:54:16.306876-05:00","updated_at":"2025-12-21T22:58:07.423603-05:00","closed_at":"2025-12-21T22:58:07.423603-05:00","close_reason":"Fixed by commit 3a8b772c on Dec 15 - refactored to use static TypeScript data instead of API fetch","labels":["bug"]}
{"id":"postplayhouse.com-9qn","title":"Create list pending bios API endpoint","description":"## Goal\nCreate an API endpoint that returns all pending bio submissions for the current season, accessible only to admin users.\n\n## Background\nThe admin bio approval UI needs to fetch a list of all pending bios waiting for review. This endpoint validates admin access and returns the pending bios from Netlify Blobs storage.\n\n## Implementation\n\n### Create `src/routes/api/admin/bios/+server.ts`\n\n```typescript\nimport { json, error } from \"@sveltejs/kit\"\nimport { individualPassphraseDetails, isAdmin } from \"$routes/api/bio-submission/passphraseHelpers\"\nimport { listPendingBios } from \"$lib/server/blobs\"\nimport * as site from \"$data/site\"\n\nexport const GET = async ({ request }) =\u003e {\n  // Validate admin access\n  const { correct, position } = individualPassphraseDetails(request)\n  \n  if (!correct) {\n    return error(403, { message: \"Invalid passphrase\" })\n  }\n  \n  if (!isAdmin(position)) {\n    return error(403, { message: \"Admin access required\" })\n  }\n\n  try {\n    const pendingBios = await listPendingBios(site.season)\n    \n    return json({\n      bios: pendingBios,\n      season: site.season,\n      adminPosition: position,\n    })\n  } catch (err) {\n    console.error(\"Failed to list pending bios:\", err)\n    return error(500, { message: \"Failed to fetch pending bios\" })\n  }\n}\n```\n\n## Response Format\n```typescript\n{\n  bios: PendingBio[],  // Array of pending bios\n  season: number,       // Current season (e.g., 2026)\n  adminPosition: number // Position of authenticated admin\n}\n```\n\nWhere `PendingBio` has this structure (from `src/lib/server/blobs.ts`):\n```typescript\n{\n  position: number\n  firstName: string\n  lastName: string\n  location: string\n  email: string\n  bio: string\n  programBio?: string\n  staffPositions?: string[]\n  productionPositions?: Record\u003cstring, string[]\u003e\n  roles?: Record\u003cstring, string[]\u003e\n  originalImageUrl: string\n  optimizedImageUrl?: string  // Not set for pending bios\n  imageYear: number\n  submittedAt: string\n  approvedAt?: string         // Not set for pending bios\n  approvedBy?: string         // Not set for pending bios\n}\n```\n\n## Dependencies\n- `src/routes/api/bio-submission/passphraseHelpers.ts` - for `individualPassphraseDetails()` and `isAdmin()`\n- `src/lib/server/blobs.ts` - for `listPendingBios()`\n- `src/data/site.ts` - for current `season`\n\n## Authentication\n- Passphrase sent in Authorization header\n- Must be a valid passphrase (position exists)\n- Position must be in ADMIN_PASSPHRASE_POSITIONS env var\n\n## Verification\n1. Start dev server: `pnpm dev`\n2. Submit a test bio at /bio-submission/\n3. Test with non-admin passphrase:\n   ```bash\n   curl -H \"Authorization: non_admin_phrase\" http://localhost:5173/api/admin/bios\n   # Should return 403\n   ```\n4. Test with admin passphrase:\n   ```bash\n   curl -H \"Authorization: admin_phrase\" http://localhost:5173/api/admin/bios\n   # Should return JSON with bios array\n   ```\n5. Verify submitted bio appears in the response","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T00:21:50.703953-05:00","created_by":"dondenton","updated_at":"2026-01-11T00:21:50.703953-05:00","dependencies":[{"issue_id":"postplayhouse.com-9qn","depends_on_id":"postplayhouse.com-k6z","type":"blocks","created_at":"2026-01-11T14:13:15.623292-05:00","created_by":"dondenton"}]}
{"id":"postplayhouse.com-a1q","title":"Create approve bio API endpoint","description":"## Goal\nCreate an API endpoint that allows admins to approve a pending bio submission. This triggers image optimization and moves the bio from pending to approved status.\n\n## Background\nWhen an admin approves a bio:\n1. The original headshot image is fetched from B2 or filesystem\n2. Sharp processes it (resize to 800x800 max, quality 80, progressive JPEG)\n3. The optimized image is uploaded to B2's optimized/ folder\n4. The bio is moved from pending to approved in Netlify Blobs\n5. The admin's identity is recorded in the approvedBy field\n\n## Implementation\n\n### Create `src/routes/api/admin/bios/approve/+server.ts`\n\n```typescript\nimport { json, error } from \"@sveltejs/kit\"\nimport { individualPassphraseDetails, isAdmin } from \"$routes/api/bio-submission/passphraseHelpers\"\nimport { getPendingBio, approveBio } from \"$lib/server/blobs\"\nimport { downloadFromB2, uploadBufferToB2 } from \"$lib/server/b2\"\nimport { processHeadshotImage, getOptimizedImagePath } from \"$lib/server/imageProcessing\"\nimport * as site from \"$data/site\"\nimport * as fs from \"node:fs/promises\"\nimport * as path from \"node:path\"\n\nexport const POST = async ({ request }) =\u003e {\n  // Validate admin access\n  const { correct, position: adminPosition } = individualPassphraseDetails(request)\n  \n  if (!correct) {\n    return error(403, { message: \"Invalid passphrase\" })\n  }\n  \n  if (!isAdmin(adminPosition)) {\n    return error(403, { message: \"Admin access required\" })\n  }\n\n  // Parse request body\n  const body = await request.json()\n  const bioPosition = body.position as number\n  \n  if (typeof bioPosition !== \"number\") {\n    return error(400, { message: \"Position is required\" })\n  }\n\n  // Fetch the pending bio\n  const pendingBio = await getPendingBio(site.season, bioPosition)\n  \n  if (!pendingBio) {\n    return error(404, { message: \"Pending bio not found\" })\n  }\n\n  try {\n    // Step 1: Fetch original image\n    let imageBuffer: Buffer\n    \n    if (pendingBio.originalImageUrl.startsWith(\"src/images/\")) {\n      // Old headshot from filesystem\n      const fullPath = path.join(process.cwd(), pendingBio.originalImageUrl)\n      imageBuffer = await fs.readFile(fullPath)\n    } else {\n      // New upload from B2\n      imageBuffer = await downloadFromB2(pendingBio.originalImageUrl)\n    }\n\n    // Step 2: Process image with Sharp\n    const optimizedBuffer = await processHeadshotImage(imageBuffer)\n\n    // Step 3: Upload optimized image to B2\n    const optimizedPath = getOptimizedImagePath(\n      site.season,\n      pendingBio.firstName,\n      pendingBio.lastName\n    )\n    await uploadBufferToB2(optimizedBuffer, optimizedPath, \"image/jpeg\")\n\n    // Step 4: Move bio to approved status\n    const approvedBy = \\`admin-position-\\${adminPosition}\\`\n    const approvedBio = await approveBio(\n      site.season,\n      bioPosition,\n      approvedBy,\n      optimizedPath\n    )\n\n    return json({\n      success: true,\n      bio: approvedBio,\n      optimizedImageUrl: optimizedPath,\n    })\n  } catch (err) {\n    console.error(\"Failed to approve bio:\", err)\n    return error(500, { \n      message: \\`Failed to approve bio: \\${err instanceof Error ? err.message : \"Unknown error\"}\\`\n    })\n  }\n}\n```\n\n## Request Format\n```typescript\nPOST /api/admin/bios/approve\nHeaders: { Authorization: \"admin_passphrase\" }\nBody: { position: number }\n```\n\n## Response Format\n```typescript\n// Success (200)\n{\n  success: true,\n  bio: PendingBio,        // The approved bio with updated fields\n  optimizedImageUrl: string  // Path to optimized image in B2\n}\n\n// Error (400/403/404/500)\n{\n  message: string\n}\n```\n\n## Dependencies\n- `src/routes/api/bio-submission/passphraseHelpers.ts` - admin authentication\n- `src/lib/server/blobs.ts` - getPendingBio, approveBio\n- `src/lib/server/b2.ts` - downloadFromB2, uploadBufferToB2\n- `src/lib/server/imageProcessing.ts` - processHeadshotImage, getOptimizedImagePath\n- `src/data/site.ts` - current season\n\n## What approveBio() Does (from blobs.ts)\n1. Fetches pending bio from \\`{season}/pending/{position}\\`\n2. Adds approvedAt timestamp and approvedBy string\n3. Sets optimizedImageUrl\n4. Saves to \\`{season}/approved/{position}\\`\n5. Deletes from pending\n\n## Error Handling\n- 400: Missing or invalid position\n- 403: Invalid passphrase or not an admin\n- 404: Pending bio not found\n- 500: Image processing or storage failure\n\n## Verification\n1. Submit a test bio at /bio-submission/\n2. Note the position number\n3. Call approve endpoint:\n   ```bash\n   curl -X POST \\\n     -H \"Authorization: admin_passphrase\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"position\": 1}' \\\n     http://localhost:5173/api/admin/bios/approve\n   ```\n4. Verify response includes optimizedImageUrl\n5. Verify bio moved from pending to approved in Blobs\n6. Verify optimized image exists in B2 optimized/ folder\n7. Verify /api/people/2026.json includes the approved bio","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T00:27:48.807841-05:00","created_by":"dondenton","updated_at":"2026-01-11T00:27:48.807841-05:00","dependencies":[{"issue_id":"postplayhouse.com-a1q","depends_on_id":"postplayhouse.com-chd","type":"blocks","created_at":"2026-01-11T00:30:59.627075-05:00","created_by":"dondenton"},{"issue_id":"postplayhouse.com-a1q","depends_on_id":"postplayhouse.com-pd5","type":"blocks","created_at":"2026-01-11T00:31:04.835575-05:00","created_by":"dondenton"}]}
{"id":"postplayhouse.com-aad","title":"Create reject bio API endpoint","description":"## Goal\nCreate an API endpoint that allows admins to reject a pending bio submission. This deletes the bio and sends a Basecamp notification.\n\n## Background\nWhen an admin rejects a bio:\n1. The pending bio is deleted from Netlify Blobs\n2. A message is sent to the Basecamp admin chat room notifying about the rejection\n3. The admin can optionally provide a reason that's included in the notification\n\nNote: Original images in B2 are NOT deleted on rejection - they remain for potential re-submission or archival purposes.\n\n## Implementation\n\n### Create `src/routes/api/admin/bios/reject/+server.ts`\n\n```typescript\nimport { json, error } from \"@sveltejs/kit\"\nimport { individualPassphraseDetails, isAdmin } from \"$routes/api/bio-submission/passphraseHelpers\"\nimport { getPendingBio, deletePendingBio } from \"$lib/server/blobs\"\nimport { sendMessageToChatRoom } from \"$routes/api/basecamp.server\"\nimport * as site from \"$data/site\"\n\nexport const POST = async ({ request, fetch }) =\u003e {\n  // Validate admin access\n  const { correct, position: adminPosition } = individualPassphraseDetails(request)\n  \n  if (!correct) {\n    return error(403, { message: \"Invalid passphrase\" })\n  }\n  \n  if (!isAdmin(adminPosition)) {\n    return error(403, { message: \"Admin access required\" })\n  }\n\n  // Parse request body\n  const body = await request.json()\n  const bioPosition = body.position as number\n  const reason = body.reason as string | undefined\n  \n  if (typeof bioPosition !== \"number\") {\n    return error(400, { message: \"Position is required\" })\n  }\n\n  // Fetch the pending bio (to get name/email for notification)\n  const pendingBio = await getPendingBio(site.season, bioPosition)\n  \n  if (!pendingBio) {\n    return error(404, { message: \"Pending bio not found\" })\n  }\n\n  try {\n    // Step 1: Delete the pending bio\n    await deletePendingBio(site.season, bioPosition)\n\n    // Step 2: Send Basecamp notification\n    const personName = \\`\\${pendingBio.firstName} \\${pendingBio.lastName}\\`\n    const reasonText = reason ? \\`\\nReason: \\${reason}\\` : \"\"\n    const messageContent = [\n      \\`Bio REJECTED for \\${personName}\\`,\n      \\`Email: \\${pendingBio.email}\\`,\n      reasonText,\n      \"\",\n      \"The person should be contacted directly to discuss needed changes.\",\n    ]\n      .filter(Boolean)\n      .join(\"\\\\n\")\n\n    // Send to admin chat room (fire-and-forget)\n    sendMessageToChatRoom(fetch, \"admin\", messageContent)\n\n    return json({\n      success: true,\n      message: \\`Bio for \\${personName} has been rejected and removed.\\`,\n    })\n  } catch (err) {\n    console.error(\"Failed to reject bio:\", err)\n    return error(500, { \n      message: \\`Failed to reject bio: \\${err instanceof Error ? err.message : \"Unknown error\"}\\`\n    })\n  }\n}\n```\n\n## Request Format\n```typescript\nPOST /api/admin/bios/reject\nHeaders: { Authorization: \"admin_passphrase\" }\nBody: { \n  position: number,\n  reason?: string  // Optional reason for rejection\n}\n```\n\n## Response Format\n```typescript\n// Success (200)\n{\n  success: true,\n  message: string  // Confirmation message\n}\n\n// Error (400/403/404/500)\n{\n  message: string\n}\n```\n\n## Basecamp Message Format\nSent to the \"admin\" chat room:\n```\nBio REJECTED for John Doe\nEmail: johndoe@example.com\nReason: Bio needs to be shorter (if provided)\n\nThe person should be contacted directly to discuss needed changes.\n```\n\n## Dependencies\n- `src/routes/api/bio-submission/passphraseHelpers.ts` - admin authentication\n- `src/lib/server/blobs.ts` - getPendingBio, deletePendingBio\n- `src/routes/api/basecamp.server.ts` - sendMessageToChatRoom\n\n## Basecamp Integration Notes\nThe `sendMessageToChatRoom` function from `basecamp.server.ts`:\n- Takes fetch, room name (\"admin\" or \"websiteUpdates\"), and content\n- Posts to Basecamp bot integration endpoint\n- Fire-and-forget (no await, errors logged but not thrown)\n\n## Why Keep Original Images\nOriginal images in B2 are NOT deleted when rejecting:\n1. Person may fix issues and resubmit\n2. Storage cost is minimal\n3. Avoids complexity of tracking which images to delete\n4. Provides audit trail\n\n## Verification\n1. Submit a test bio at /bio-submission/\n2. Note the position number\n3. Call reject endpoint:\n   ```bash\n   curl -X POST \\\n     -H \"Authorization: admin_passphrase\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"position\": 1, \"reason\": \"Bio is too long\"}' \\\n     http://localhost:5173/api/admin/bios/reject\n   ```\n4. Verify response indicates success\n5. Verify bio no longer appears in /api/admin/bios list\n6. Check Basecamp admin chat for rejection notification\n7. Verify original image still exists in B2 (not deleted)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T00:28:03.53574-05:00","created_by":"dondenton","updated_at":"2026-01-11T00:28:03.53574-05:00","dependencies":[{"issue_id":"postplayhouse.com-aad","depends_on_id":"postplayhouse.com-k6z","type":"blocks","created_at":"2026-01-11T14:13:15.714743-05:00","created_by":"dondenton"}]}
{"id":"postplayhouse.com-ags","title":"Try out beads","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-21T14:40:33.198421-05:00","updated_at":"2025-12-21T14:54:22.174857-05:00","closed_at":"2025-12-21T14:54:22.174857-05:00","close_reason":"Beads setup verified complete: daemon running, config set, JSONL tracked in git"}
{"id":"postplayhouse.com-bqq","title":"Add Playwright tests for admin bio approval","description":"## Goal\nAdd comprehensive Playwright tests for the admin bio approval flow to ensure the feature works correctly end-to-end.\n\n## Background\nThe existing test file at `tests/test.ts` contains bio submission tests. We need to add admin-specific tests following the same patterns.\n\n## Implementation\n\n### Add to `tests/test.ts`\n\n```typescript\ntest.describe(\"Admin Bio Approval\", () =\u003e {\n  // Helper to get admin passphrase from env\n  function getAdminPassphrase(): string | null {\n    const passphraseList = process.env.INDIVIDUAL_PASSPHRASES_LIST\n    const adminPositions = process.env.ADMIN_PASSPHRASE_POSITIONS\n    if (!passphraseList || !adminPositions) return null\n    \n    // Get the first admin position\n    const firstAdminPos = parseInt(adminPositions.split(\",\")[0], 10)\n    if (isNaN(firstAdminPos) || firstAdminPos \u003c 1) return null\n    \n    // Get passphrase at that position (1-indexed)\n    const phrases = passphraseList.split(\",\")\n    return phrases[firstAdminPos - 1] || null\n  }\n\n  // Helper to get non-admin passphrase\n  function getNonAdminPassphrase(): string | null {\n    const passphraseList = process.env.INDIVIDUAL_PASSPHRASES_LIST\n    const adminPositions = process.env.ADMIN_PASSPHRASE_POSITIONS\n    if (!passphraseList) return null\n    \n    const adminPosSet = new Set(\n      (adminPositions || \"\").split(\",\").map((p) =\u003e parseInt(p, 10))\n    )\n    \n    const phrases = passphraseList.split(\",\")\n    for (let i = 0; i \u003c phrases.length; i++) {\n      if (!adminPosSet.has(i + 1)) {\n        return phrases[i]\n      }\n    }\n    return null\n  }\n\n  test(\"admin page shows passphrase form\", async ({ page }) =\u003e {\n    await page.goto(\"/admin/bios\")\n    await expect(page).toHaveTitle(/Admin: Bio Approval/)\n    await expect(page.getByText(\"Admin Passphrase\")).toBeVisible()\n  })\n\n  test(\"non-admin passphrase is rejected\", async ({ page }) =\u003e {\n    const nonAdminPhrase = getNonAdminPassphrase()\n    if (!nonAdminPhrase) {\n      test.skip()\n      return\n    }\n\n    await page.goto(\"/admin/bios\")\n    await page.locator('input[type=\"text\"]').fill(nonAdminPhrase)\n    await page.getByRole(\"button\", { name: \"Access Admin\" }).click()\n\n    await expect(page.getByText(\"Admin access required\")).toBeVisible({\n      timeout: 10000,\n    })\n  })\n\n  test(\"invalid passphrase shows error\", async ({ page }) =\u003e {\n    await page.goto(\"/admin/bios\")\n    await page.locator('input[type=\"text\"]').fill(\"invalid_passphrase_xyz\")\n    await page.getByRole(\"button\", { name: \"Access Admin\" }).click()\n\n    await expect(page.getByText(/Invalid passphrase|not an admin/)).toBeVisible({\n      timeout: 10000,\n    })\n  })\n\n  test(\"admin passphrase shows pending bios list\", async ({ page }) =\u003e {\n    const adminPhrase = getAdminPassphrase()\n    if (!adminPhrase) {\n      test.skip()\n      return\n    }\n\n    await page.goto(\"/admin/bios\")\n    await page.locator('input[type=\"text\"]').fill(adminPhrase)\n    await page.getByRole(\"button\", { name: \"Access Admin\" }).click()\n\n    // Should show the pending bios section\n    await expect(page.getByText(/Pending Bios for \\d{4}/)).toBeVisible({\n      timeout: 10000,\n    })\n  })\n\n  test(\"GET /api/admin/bios rejects non-admin passphrase\", async ({\n    request,\n  }) =\u003e {\n    const nonAdminPhrase = getNonAdminPassphrase()\n    if (!nonAdminPhrase) {\n      test.skip()\n      return\n    }\n\n    const response = await request.get(\"/api/admin/bios\", {\n      headers: { Authorization: nonAdminPhrase },\n    })\n    expect(response.status()).toBe(403)\n  })\n\n  test(\"GET /api/admin/bios accepts admin passphrase\", async ({ request }) =\u003e {\n    const adminPhrase = getAdminPassphrase()\n    if (!adminPhrase) {\n      test.skip()\n      return\n    }\n\n    const response = await request.get(\"/api/admin/bios\", {\n      headers: { Authorization: adminPhrase },\n    })\n    expect(response.ok()).toBeTruthy()\n\n    const data = await response.json()\n    expect(data.bios).toBeDefined()\n    expect(Array.isArray(data.bios)).toBe(true)\n    expect(data.season).toBeDefined()\n  })\n\n  test(\"POST /api/admin/bios/approve requires admin auth\", async ({\n    request,\n  }) =\u003e {\n    const response = await request.post(\"/api/admin/bios/approve\", {\n      headers: {\n        Authorization: \"invalid_phrase\",\n        \"Content-Type\": \"application/json\",\n      },\n      data: { position: 1 },\n    })\n    expect(response.status()).toBe(403)\n  })\n\n  test(\"POST /api/admin/bios/reject requires admin auth\", async ({\n    request,\n  }) =\u003e {\n    const response = await request.post(\"/api/admin/bios/reject\", {\n      headers: {\n        Authorization: \"invalid_phrase\",\n        \"Content-Type\": \"application/json\",\n      },\n      data: { position: 1, reason: \"test\" },\n    })\n    expect(response.status()).toBe(403)\n  })\n\n  test(\"POST /api/admin/bios/purge-cache requires admin auth\", async ({\n    request,\n  }) =\u003e {\n    const response = await request.post(\"/api/admin/bios/purge-cache\", {\n      headers: { Authorization: \"invalid_phrase\" },\n    })\n    expect(response.status()).toBe(403)\n  })\n\n  // Note: Full approval/rejection flow tests would require:\n  // 1. Submitting a bio first\n  // 2. Then approving/rejecting it\n  // 3. These are integration tests that may need Netlify Blobs/B2\n  test.describe(\"Full Approval Flow (Integration)\", () =\u003e {\n    test(\"submit and approve a bio\", async ({ page, request }) =\u003e {\n      const adminPhrase = getAdminPassphrase()\n      const submitterPhrase = process.env.INDIVIDUAL_PASSPHRASES_LIST?.split(\",\")[0]\n      \n      if (!adminPhrase || !submitterPhrase) {\n        test.skip()\n        return\n      }\n\n      // Step 1: Submit a bio\n      await page.goto(\"/bio-submission/\")\n      await page.waitForLoadState(\"networkidle\")\n      await page.locator('input[name=\"passphrase\"]').fill(submitterPhrase)\n      await page.getByRole(\"button\", { name: \"Continue\" }).click()\n      await expect(page.locator('input[name=\"email\"]')).toBeVisible({ timeout: 15000 })\n\n      const testId = Date.now()\n      await page.locator('input[name=\"email\"]').fill(\"test@example.com\")\n      await page.locator('input[name=\"firstName\"]').fill(\\`Test\\${testId}\\`)\n      await page.locator('input[name=\"lastName\"]').fill(\"Admin\")\n      await page.locator('input[name=\"location\"]').fill(\"Test City\")\n      await page.getByText(\"I've worked at Post before\").click()\n      await page.locator(\"ul.h-96 button\").first().click()\n      const bioEditor = page.locator(\".ProseMirror\").first()\n      await bioEditor.click()\n      await bioEditor.fill(\"Test bio for admin approval testing.\")\n\n      await page.getByRole(\"button\", { name: \"Submit Bio\" }).click()\n      \n      // Wait for submission (success or error due to infrastructure)\n      const result = page.getByText(\"Success!\").or(page.getByText(\"Oh no.\"))\n      await expect(result).toBeVisible({ timeout: 30000 })\n\n      // Step 2: If submission succeeded, try to approve via API\n      // Note: This may fail in local dev without Netlify Blobs\n    })\n  })\n})\n```\n\n## Test Categories\n\n### Unit/API Tests\n1. Auth rejection for non-admin passphrase\n2. Auth rejection for invalid passphrase\n3. Auth acceptance for admin passphrase\n4. List pending bios returns array\n5. Approve/Reject/Purge endpoints require admin auth\n\n### UI Tests\n1. Admin page renders passphrase form\n2. Non-admin passphrase shows error\n3. Invalid passphrase shows error\n4. Admin passphrase shows pending bios list\n\n### Integration Tests (May Need Infrastructure)\n1. Full submit → approve flow\n2. Full submit → reject flow\n3. Cache purge after approvals\n\n## Environment Variables Required for Tests\n- `INDIVIDUAL_PASSPHRASES_LIST` - comma-separated passphrases\n- `ADMIN_PASSPHRASE_POSITIONS` - comma-separated admin positions\n\n## Running Tests\n```bash\n# Run all tests\npnpm test\n\n# Run only admin tests\npnpm test --grep \"Admin Bio Approval\"\n```\n\n## Notes\n- Some tests require actual Netlify Blobs/B2 infrastructure\n- Tests gracefully skip when env vars are missing\n- Integration tests may pass in CI with proper env setup but fail locally\n\n## Verification\n1. Ensure env vars are set (or tests will skip)\n2. Run `pnpm test`\n3. Verify admin tests pass\n4. Check test output for skipped tests due to missing env","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-11T00:30:29.344128-05:00","created_by":"dondenton","updated_at":"2026-01-11T00:30:29.344128-05:00","dependencies":[{"issue_id":"postplayhouse.com-bqq","depends_on_id":"postplayhouse.com-cr8","type":"blocks","created_at":"2026-01-11T00:31:36.57781-05:00","created_by":"dondenton"}]}
{"id":"postplayhouse.com-chd","title":"Extract B2 utilities to shared module","description":"## Goal\nExtract B2 (Backblaze) storage functions from the bio submission endpoint into a shared server module for reuse by the admin approval flow.\n\n## Background\nThe bio submission endpoint (`src/routes/api/bio-submission/submit/+server.ts`) contains B2 functions that need to be reused by the admin approval system for image processing. These functions handle authentication with B2 and file upload/download operations.\n\n## Implementation\n\n### Create `src/lib/server/b2.ts`\n\nExtract and enhance these functions from submit/+server.ts:\n\n```typescript\nimport { env } from \"$env/dynamic/private\"\nimport { isProduction } from \"$lib/server/env\"\nimport type { AuthorizeAccountSuccessResponse } from \"$routes/api/bio-submission/upload-url/b2-types\"\n\n// Select bucket based on environment (test bucket for dev/test, prod bucket for production)\nfunction getB2Config() {\n  const useTestBucket = !isProduction()\n  return {\n    keyId: env[\"B2_APPLICATION_KEY_ID\"],\n    key: env[\"B2_APPLICATION_KEY\"],\n    bucketId: useTestBucket \n      ? env[\"B2_TEST_BUCKET_ID\"] \n      : env[\"B2_BUCKET_ID\"],\n    bucketName: useTestBucket\n      ? env[\"B2_TEST_BUCKET_NAME\"]\n      : env[\"B2_BUCKET_NAME\"],\n  }\n}\n\nfunction base64Encode(str: string): string {\n  return Buffer.from(str).toString(\"base64\")\n}\n\n// Authenticate with B2 and get API URL + auth token\nasync function authorizeB2(): Promise\u003cAuthorizeAccountSuccessResponse\u003e {\n  const config = getB2Config()\n  const auth = \"Basic \" + base64Encode(`${config.keyId}:${config.key}`)\n  const resp = await fetch(\"https://api.backblazeb2.com/b2api/v2/b2_authorize_account\", {\n    headers: { Authorization: auth },\n    method: \"GET\",\n  })\n  if (!resp.ok) {\n    throw new Error(\"Could not authorize account for storage provider\")\n  }\n  return resp.json()\n}\n\n// Get upload credentials (URL + token)\nexport async function getB2UploadCreds(): Promise\u003c{\n  uploadUrl: string\n  authorizationToken: string\n}\u003e {\n  const config = getB2Config()\n  const authData = await authorizeB2()\n  const resp = await fetch(authData.apiUrl + \"/b2api/v2/b2_get_upload_url\", {\n    method: \"POST\",\n    body: JSON.stringify({ bucketId: config.bucketId }),\n    headers: { Authorization: authData.authorizationToken },\n  })\n  if (!resp.ok) {\n    throw new Error(\"Could not fetch upload endpoint details\")\n  }\n  const { uploadUrl, authorizationToken } = await resp.json()\n  return { uploadUrl, authorizationToken }\n}\n\n// Upload a File to B2\nexport async function uploadFileToB2(file: File, fileName: string): Promise\u003cstring\u003e {\n  const { uploadUrl, authorizationToken } = await getB2UploadCreds()\n  const resp = await fetch(uploadUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": file.type,\n      Authorization: authorizationToken,\n      \"X-Bz-Content-Sha1\": \"do_not_verify\",\n      \"X-Bz-File-Name\": fileName,\n      \"Content-Length\": file.size.toString(),\n    },\n    body: file,\n  })\n  if (!resp.ok) {\n    throw new Error(`Could not upload file to B2: ${await resp.text()}`)\n  }\n  const result = await resp.json()\n  return result.fileName\n}\n\n// Upload a Buffer to B2 (for processed images)\nexport async function uploadBufferToB2(\n  buffer: Buffer,\n  fileName: string,\n  contentType: string\n): Promise\u003cstring\u003e {\n  const { uploadUrl, authorizationToken } = await getB2UploadCreds()\n  const resp = await fetch(uploadUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": contentType,\n      Authorization: authorizationToken,\n      \"X-Bz-Content-Sha1\": \"do_not_verify\",\n      \"X-Bz-File-Name\": fileName,\n      \"Content-Length\": buffer.length.toString(),\n    },\n    body: buffer,\n  })\n  if (!resp.ok) {\n    throw new Error(`Could not upload buffer to B2: ${await resp.text()}`)\n  }\n  const result = await resp.json()\n  return result.fileName\n}\n\n// Download a file from B2 (returns Buffer)\nexport async function downloadFromB2(filePath: string): Promise\u003cBuffer\u003e {\n  const config = getB2Config()\n  const authData = await authorizeB2()\n  // B2 download URL format: {downloadUrl}/file/{bucketName}/{fileName}\n  const downloadUrl = `${authData.downloadUrl}/file/${config.bucketName}/${filePath}`\n  const resp = await fetch(downloadUrl, {\n    headers: { Authorization: authData.authorizationToken },\n  })\n  if (!resp.ok) {\n    throw new Error(`Could not download file from B2: ${resp.status}`)\n  }\n  return Buffer.from(await resp.arrayBuffer())\n}\n```\n\n### Modify `src/routes/api/bio-submission/submit/+server.ts`\n\nReplace inline B2 functions with imports:\n\n```typescript\nimport { uploadFileToB2 } from \"$lib/server/b2\"\n\n// Remove: b2Creds, base64Encode, getB2UploadCreds, uploadImageToB2\n// Update uploadImageToB2 calls to use uploadFileToB2\n```\n\n### Update `.env.example`\n\nAdd documentation for new test bucket variables:\n\n```bash\n# B2 Storage - Production bucket\nB2_BUCKET_ID=SOME_ID\nB2_BUCKET_NAME=postplayhouse-prod\nB2_APPLICATION_KEY_ID=SOME_ID\nB2_APPLICATION_KEY=SOME_KEY\n\n# B2 Storage - Test bucket (used in dev/test/preview environments)\n# Create a separate bucket in Backblaze for non-production use\nB2_TEST_BUCKET_ID=TEST_BUCKET_ID\nB2_TEST_BUCKET_NAME=postplayhouse-test\n```\n\n## Environment Variables\n\n**Existing:**\n- `B2_APPLICATION_KEY_ID` - B2 API key ID (shared across buckets)\n- `B2_APPLICATION_KEY` - B2 API key secret (shared across buckets)\n- `B2_BUCKET_ID` - Production bucket ID\n\n**New:**\n- `B2_BUCKET_NAME` - Production bucket name (needed for download URLs)\n- `B2_TEST_BUCKET_ID` - Test bucket ID\n- `B2_TEST_BUCKET_NAME` - Test bucket name\n\n## Playwright Tests\n\nAdd to `tests/b2.test.ts`:\n\n```typescript\nimport { expect, test } from \"@playwright/test\"\n\ntest.describe(\"B2 Storage Integration\", () =\u003e {\n  test(\"bio submission with new image uploads to B2\", async ({ page }) =\u003e {\n    const testPassphrase = process.env.INDIVIDUAL_PASSPHRASES_LIST?.split(\",\")[0]\n    if (!testPassphrase) {\n      test.skip()\n      return\n    }\n\n    await page.goto(\"/bio-submission/\")\n    await page.waitForLoadState(\"networkidle\")\n    await page.locator('input[name=\"passphrase\"]').fill(testPassphrase)\n    await page.getByRole(\"button\", { name: \"Continue\" }).click()\n    await expect(page.locator('input[name=\"email\"]')).toBeVisible({ timeout: 15000 })\n\n    // Fill required fields\n    await page.locator('input[name=\"email\"]').fill(\"test@example.com\")\n    await page.locator('input[name=\"firstName\"]').fill(\"TestB2\")\n    await page.locator('input[name=\"lastName\"]').fill(\"Upload\")\n    await page.locator('input[name=\"location\"]').fill(\"Test City, NE\")\n\n    // Select \"new headshot\" and upload a test image\n    await page.getByText(\"I have a new headshot\").click()\n    \n    // Create a test image file\n    const testImageBuffer = Buffer.from(\n      \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==\",\n      \"base64\"\n    )\n    await page.locator('input[type=\"file\"]').setInputFiles({\n      name: \"test-image.png\",\n      mimeType: \"image/png\",\n      buffer: testImageBuffer,\n    })\n\n    // Fill bio\n    const bioEditor = page.locator(\".ProseMirror\").first()\n    await bioEditor.click()\n    await bioEditor.fill(\"TestB2 Upload is testing B2 integration!\")\n\n    // Submit\n    const submitButton = page.getByRole(\"button\", { name: \"Submit Bio\" })\n    await expect(submitButton).toBeEnabled()\n    await submitButton.click()\n\n    // Should succeed (uploads to test bucket in non-prod)\n    await expect(page.getByText(\"Success!\")).toBeVisible({ timeout: 30000 })\n  })\n})\n```\n\n## Verification\n1. Ensure `B2_TEST_BUCKET_ID` and `B2_TEST_BUCKET_NAME` are set in .env\n2. Run `pnpm dev` and submit a test bio with a new image\n3. Verify image uploads to **test bucket** (check B2 console)\n4. Run `pnpm test:integration` - B2 tests should pass\n5. In production deploy, verify images go to production bucket\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T00:11:29.686583-05:00","created_by":"dondenton","updated_at":"2026-01-11T14:16:21.370373-05:00","dependencies":[{"issue_id":"postplayhouse.com-chd","depends_on_id":"postplayhouse.com-k6z","type":"blocks","created_at":"2026-01-11T14:13:15.534702-05:00","created_by":"dondenton"}]}
{"id":"postplayhouse.com-cr8","title":"Create admin bios page UI","description":"## Goal\nCreate the admin UI page at `/admin/bios` for reviewing and approving/rejecting pending bio submissions.\n\n## Background\nThis is the main admin interface where authorized users:\n1. Authenticate with their passphrase\n2. View all pending bios with image previews\n3. Approve or reject individual bios\n4. Trigger cache purge when done approving\n\nThe UI follows the same patterns as the existing bio-submission page for consistency.\n\n## Implementation\n\n### Create `src/routes/(app)/admin/bios/+page.server.ts`\n\n```typescript\n// Disable prerendering - this page needs dynamic auth\nexport const prerender = false\n```\n\n### Create `src/routes/(app)/admin/bios/+page.svelte`\n\n```svelte\n\u003cscript lang=\"ts\"\u003e\n  import { sanitizedPassphrase } from \"$helpers\"\n  import Bio from \"$components/Bio.svelte\"\n  import type { PendingBio } from \"$lib/server/blobs\"\n\n  // Page states\n  type PageState = \"unauthenticated\" | \"authenticating\" | \"authenticated\" | \"error\"\n  \n  let pageState = $state\u003cPageState\u003e(\"unauthenticated\")\n  let passphrase = $state(\"\")\n  let authError = $state(\"\")\n  let pendingBios = $state\u003cPendingBio[]\u003e([])\n  let season = $state(0)\n\n  // Processing states per bio\n  let processingBios = $state\u003cRecord\u003cnumber, \"approving\" | \"rejecting\" | null\u003e\u003e({})\n  \n  // Reject modal state\n  let rejectingBio = $state\u003cPendingBio | null\u003e(null)\n  let rejectReason = $state(\"\")\n  \n  // Cache purge state\n  let isPurging = $state(false)\n  let purgeResult = $state\u003c{ success: boolean; message: string } | null\u003e(null)\n\n  function getAuthHeaders() {\n    return { Authorization: sanitizedPassphrase(passphrase) }\n  }\n\n  async function authenticate() {\n    pageState = \"authenticating\"\n    authError = \"\"\n\n    try {\n      const response = await fetch(\"/api/admin/bios\", {\n        headers: getAuthHeaders(),\n      })\n\n      if (response.status === 403) {\n        const data = await response.json()\n        authError = data.message || \"Invalid passphrase or not an admin\"\n        pageState = \"unauthenticated\"\n        return\n      }\n\n      if (!response.ok) {\n        throw new Error(\"Failed to fetch bios\")\n      }\n\n      const data = await response.json()\n      pendingBios = data.bios\n      season = data.season\n      pageState = \"authenticated\"\n    } catch (e) {\n      authError = \"An error occurred. Please try again.\"\n      pageState = \"unauthenticated\"\n    }\n  }\n\n  async function approveBio(bio: PendingBio) {\n    processingBios[bio.position] = \"approving\"\n\n    try {\n      const response = await fetch(\"/api/admin/bios/approve\", {\n        method: \"POST\",\n        headers: {\n          ...getAuthHeaders(),\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ position: bio.position }),\n      })\n\n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.message || \"Failed to approve\")\n      }\n\n      // Remove from list on success\n      pendingBios = pendingBios.filter((b) =\u003e b.position !== bio.position)\n    } catch (e) {\n      alert(\\`Error approving bio: \\${e instanceof Error ? e.message : \"Unknown error\"}\\`)\n    } finally {\n      processingBios[bio.position] = null\n    }\n  }\n\n  function startReject(bio: PendingBio) {\n    rejectingBio = bio\n    rejectReason = \"\"\n  }\n\n  function cancelReject() {\n    rejectingBio = null\n    rejectReason = \"\"\n  }\n\n  async function confirmReject() {\n    if (!rejectingBio) return\n\n    const bio = rejectingBio\n    processingBios[bio.position] = \"rejecting\"\n\n    try {\n      const response = await fetch(\"/api/admin/bios/reject\", {\n        method: \"POST\",\n        headers: {\n          ...getAuthHeaders(),\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          position: bio.position,\n          reason: rejectReason || undefined,\n        }),\n      })\n\n      if (!response.ok) {\n        throw new Error(\"Failed to reject\")\n      }\n\n      pendingBios = pendingBios.filter((b) =\u003e b.position !== bio.position)\n      rejectingBio = null\n    } catch (e) {\n      alert(\\`Error rejecting bio: \\${e instanceof Error ? e.message : \"Unknown error\"}\\`)\n    } finally {\n      processingBios[bio.position] = null\n    }\n  }\n\n  async function doneApproving() {\n    isPurging = true\n    purgeResult = null\n\n    try {\n      const response = await fetch(\"/api/admin/bios/purge-cache\", {\n        method: \"POST\",\n        headers: getAuthHeaders(),\n      })\n\n      const data = await response.json()\n\n      if (!response.ok) {\n        throw new Error(data.message || \"Failed to purge cache\")\n      }\n\n      purgeResult = {\n        success: true,\n        message: \"Cache purged and pages warmed successfully!\",\n      }\n    } catch (e) {\n      purgeResult = {\n        success: false,\n        message: \\`Error: \\${e instanceof Error ? e.message : \"Unknown error\"}\\`,\n      }\n    } finally {\n      isPurging = false\n    }\n  }\n\n  // Convert PendingBio to format expected by Bio component\n  function toBioComponentFormat(bio: PendingBio) {\n    return {\n      name: \\`\\${bio.firstName} \\${bio.lastName}\\`,\n      // Use proxy endpoint for images\n      image: \\`/api/admin/image/\\${encodeURIComponent(bio.originalImageUrl)}?auth=\\${encodeURIComponent(sanitizedPassphrase(passphrase))}\\`,\n      location: bio.location,\n      bio: bio.bio,\n      positions: [],\n      staffPositions: bio.staffPositions || [],\n      productionPositions: Object.entries(bio.productionPositions || {}).map(\n        ([productionName, positions]) =\u003e ({ productionName, positions })\n      ),\n      roles: Object.entries(bio.roles || {}).map(\n        ([productionName, positions]) =\u003e ({ productionName, positions })\n      ),\n    }\n  }\n\n  function formatDate(isoString: string) {\n    return new Date(isoString).toLocaleString()\n  }\n\u003c/script\u003e\n\n\u003csvelte:head\u003e\n  \u003ctitle\u003eAdmin: Bio Approval\u003c/title\u003e\n\u003c/svelte:head\u003e\n\n\u003ch2 class=\"h2\"\u003eBio Approval Admin\u003c/h2\u003e\n\n{#if pageState === \"unauthenticated\" || pageState === \"authenticating\"}\n  \u003cform\n    class=\"mt-8 max-w-md\"\n    onsubmit={(e) =\u003e {\n      e.preventDefault()\n      authenticate()\n    }}\n  \u003e\n    \u003clabel class=\"block text-xl\"\u003e\n      Admin Passphrase\n      \u003cinput\n        class=\"mt-2 block w-full border p-2\"\n        type=\"text\"\n        bind:value={passphrase}\n        disabled={pageState === \"authenticating\"}\n        autocomplete=\"off\"\n      /\u003e\n    \u003c/label\u003e\n\n    {#if authError}\n      \u003cp class=\"mt-2 text-red-600\"\u003e{authError}\u003c/p\u003e\n    {/if}\n\n    \u003cbutton\n      class=\"btn btn-p mt-4\"\n      type=\"submit\"\n      disabled={pageState === \"authenticating\"}\n    \u003e\n      {pageState === \"authenticating\" ? \"Checking...\" : \"Access Admin\"}\n    \u003c/button\u003e\n  \u003c/form\u003e\n{/if}\n\n{#if pageState === \"authenticated\"}\n  \u003cdiv class=\"mt-8\"\u003e\n    \u003cdiv class=\"mb-8 flex items-center justify-between\"\u003e\n      \u003ch3 class=\"text-xl\"\u003e\n        Pending Bios for {season} ({pendingBios.length})\n      \u003c/h3\u003e\n\n      \u003cbutton\n        class=\"btn btn-p\"\n        onclick={doneApproving}\n        disabled={isPurging}\n      \u003e\n        {isPurging ? \"Purging Cache...\" : \"Done Approving (Purge Cache)\"}\n      \u003c/button\u003e\n    \u003c/div\u003e\n\n    {#if purgeResult}\n      \u003cdiv\n        class=\"mb-8 rounded p-4 {purgeResult.success\n          ? 'bg-green-100 text-green-800'\n          : 'bg-red-100 text-red-800'}\"\n      \u003e\n        {purgeResult.message}\n      \u003c/div\u003e\n    {/if}\n\n    {#if pendingBios.length === 0}\n      \u003cp class=\"text-gray-600\"\u003eNo pending bios to review.\u003c/p\u003e\n    {:else}\n      \u003cdiv class=\"space-y-12\"\u003e\n        {#each pendingBios as bio (bio.position)}\n          \u003cdiv class=\"rounded-lg border bg-white p-6 shadow\"\u003e\n            \u003cdiv class=\"mb-4 text-sm text-gray-500\"\u003e\n              Position #{bio.position} |\n              Submitted: {formatDate(bio.submittedAt)} |\n              Email: {bio.email}\n            \u003c/div\u003e\n\n            \u003cBio person={toBioComponentFormat(bio)} /\u003e\n\n            {#if bio.programBio}\n              \u003cdiv class=\"mt-4 rounded bg-gray-50 p-4\"\u003e\n                \u003cstrong\u003eProgram Bio:\u003c/strong\u003e\n                \u003cp class=\"mt-1\"\u003e{bio.programBio}\u003c/p\u003e\n              \u003c/div\u003e\n            {/if}\n\n            \u003cdiv class=\"mt-6 flex gap-4\"\u003e\n              \u003cbutton\n                class=\"btn btn-p\"\n                onclick={() =\u003e approveBio(bio)}\n                disabled={processingBios[bio.position] != null}\n              \u003e\n                {processingBios[bio.position] === \"approving\"\n                  ? \"Processing Image...\"\n                  : \"Approve\"}\n              \u003c/button\u003e\n\n              \u003cbutton\n                class=\"btn bg-red-600 text-white hover:bg-red-700\"\n                onclick={() =\u003e startReject(bio)}\n                disabled={processingBios[bio.position] != null}\n              \u003e\n                {processingBios[bio.position] === \"rejecting\"\n                  ? \"Rejecting...\"\n                  : \"Reject\"}\n              \u003c/button\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        {/each}\n      \u003c/div\u003e\n    {/if}\n  \u003c/div\u003e\n{/if}\n\n\u003c!-- Reject Modal --\u003e\n{#if rejectingBio}\n  \u003cdiv\n    class=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50\"\n    onclick={cancelReject}\n    onkeydown={(e) =\u003e e.key === \"Escape\" \u0026\u0026 cancelReject()}\n    role=\"dialog\"\n    aria-modal=\"true\"\n    tabindex=\"-1\"\n  \u003e\n    \u003cdiv\n      class=\"mx-4 w-full max-w-lg rounded-lg bg-white p-6 shadow-xl\"\n      onclick={(e) =\u003e e.stopPropagation()}\n      onkeydown={() =\u003e {}}\n      role=\"document\"\n    \u003e\n      \u003ch3 class=\"mb-4 text-xl\"\u003e\n        Reject Bio: {rejectingBio.firstName} {rejectingBio.lastName}\n      \u003c/h3\u003e\n      \u003cp class=\"mb-4 text-gray-600\"\u003e\n        This will delete the bio and notify the admin Basecamp chat room.\n      \u003c/p\u003e\n\n      \u003clabel class=\"block\"\u003e\n        Reason (optional, included in Basecamp notification):\n        \u003ctextarea\n          class=\"mt-2 block w-full rounded border p-2\"\n          rows=\"3\"\n          bind:value={rejectReason}\n          placeholder=\"e.g., Bio exceeds word limit\"\n        \u003e\u003c/textarea\u003e\n      \u003c/label\u003e\n\n      \u003cdiv class=\"mt-6 flex justify-end gap-4\"\u003e\n        \u003cbutton class=\"btn\" onclick={cancelReject}\u003eCancel\u003c/button\u003e\n        \u003cbutton\n          class=\"btn bg-red-600 text-white hover:bg-red-700\"\n          onclick={confirmReject}\n        \u003e\n          Confirm Reject\n        \u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n{/if}\n```\n\n## UI Flow\n\n### Authentication\n1. Admin visits /admin/bios\n2. Enters their passphrase\n3. Passphrase validated against /api/admin/bios\n4. If valid AND admin position, shows pending bios\n\n### Bio Review\n- Each bio displays:\n  - Position number, submission timestamp, email\n  - Image preview (via proxy endpoint)\n  - Full bio text using Bio.svelte component\n  - Program bio if provided\n  - Approve/Reject buttons\n\n### Approve Action\n1. Admin clicks \"Approve\"\n2. Button shows \"Processing Image...\"\n3. Calls /api/admin/bios/approve\n4. On success, bio removed from list\n5. On error, shows alert\n\n### Reject Action\n1. Admin clicks \"Reject\"\n2. Modal appears with reason field\n3. Admin optionally enters reason\n4. Clicks \"Confirm Reject\"\n5. Calls /api/admin/bios/reject\n6. Bio removed from list, Basecamp notified\n\n### Done Approving\n1. Admin clicks \"Done Approving (Purge Cache)\"\n2. Button shows \"Purging Cache...\"\n3. Calls /api/admin/bios/purge-cache\n4. Shows success/error message\n\n## Image Proxy Integration\nImages are displayed via `/api/admin/image/[path]?auth=[passphrase]`:\n- Handles both B2 images and local filesystem images\n- Requires valid admin passphrase for access\n- Query param auth allows usage in img src\n\nNote: The image proxy endpoint needs to support `?auth=` query param as an alternative to Authorization header for img tag compatibility.\n\n## Dependencies\n- `$components/Bio.svelte` - existing component for bio display\n- `$helpers` - sanitizedPassphrase function\n- `$lib/server/blobs` - PendingBio type (for TypeScript)\n\n## API Endpoints Used\n- GET /api/admin/bios - list pending bios\n- POST /api/admin/bios/approve - approve a bio\n- POST /api/admin/bios/reject - reject a bio\n- POST /api/admin/bios/purge-cache - purge CDN cache\n- GET /api/admin/image/[path] - proxy for images\n\n## Styling Notes\n- Uses existing btn classes (btn, btn-p)\n- Consistent with bio-submission page patterns\n- Modal implemented inline (no separate Modal component needed)\n\n## Verification\n1. Start dev server: `pnpm dev`\n2. Submit a test bio at /bio-submission/\n3. Navigate to /admin/bios\n4. Enter admin passphrase (from ADMIN_PASSPHRASE_POSITIONS)\n5. Verify pending bio appears with image\n6. Test approve - verify image processing state, bio removed\n7. Submit another bio, test reject - verify modal, Basecamp notification\n8. Test \"Done Approving\" - verify cache purge message","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T00:29:43.561489-05:00","created_by":"dondenton","updated_at":"2026-01-11T00:29:43.561489-05:00","dependencies":[{"issue_id":"postplayhouse.com-cr8","depends_on_id":"postplayhouse.com-9qn","type":"blocks","created_at":"2026-01-11T00:31:10.290661-05:00","created_by":"dondenton"},{"issue_id":"postplayhouse.com-cr8","depends_on_id":"postplayhouse.com-a1q","type":"blocks","created_at":"2026-01-11T00:31:15.496391-05:00","created_by":"dondenton"},{"issue_id":"postplayhouse.com-cr8","depends_on_id":"postplayhouse.com-aad","type":"blocks","created_at":"2026-01-11T00:31:20.700419-05:00","created_by":"dondenton"},{"issue_id":"postplayhouse.com-cr8","depends_on_id":"postplayhouse.com-x1l","type":"blocks","created_at":"2026-01-11T00:31:25.912159-05:00","created_by":"dondenton"},{"issue_id":"postplayhouse.com-cr8","depends_on_id":"postplayhouse.com-8a0","type":"blocks","created_at":"2026-01-11T00:31:31.129293-05:00","created_by":"dondenton"}]}
{"id":"postplayhouse.com-cuf","title":"TypeError: Importing a module script failed","description":"**Sentry Issue:** JAVASCRIPT-SVELTEKIT-T\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-T\n**Occurrences:** 617\n**First Seen:** 2024-03-17\n**Last Seen:** 2025-12-19\n\n**Error:** TypeError: Importing a module script failed\n**Culprit:** /(app)\n**Affected browsers:** Mobile Safari, various\n\n**Likely Cause:** Module import failures typically occur when browser cache has stale references after deployment, network interruption during module loading, or dynamic imports failing due to version mismatches.\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-21T22:54:12.786732-05:00","updated_at":"2025-12-21T23:01:12.332208-05:00","closed_at":"2025-12-21T23:01:12.332208-05:00","close_reason":"Browser caching issue, not a code bug - happens when cached JS modules become stale after deployments. Common with SPAs.","labels":["bug"]}
{"id":"postplayhouse.com-f0u","title":"Infrastructure setup","description":"Install @netlify/blobs and @netlify/functions. Add @netlify/vite-plugin to vite.config.ts. Create src/lib/server/blobs.ts with helpers. Add isAdmin(position) to passphraseHelpers.ts.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T00:05:58.219707-05:00","updated_at":"2025-12-22T23:06:30.416069-05:00","closed_at":"2025-12-22T23:06:30.416069-05:00","close_reason":"Infrastructure setup complete: installed @netlify/blobs, @netlify/functions, and @netlify/vite-plugin; created blobs.ts helpers; added isAdmin() function","dependencies":[{"issue_id":"postplayhouse.com-f0u","depends_on_id":"postplayhouse.com-wb6","type":"parent-child","created_at":"2025-12-22T00:06:16.894377-05:00","created_by":"daemon"}]}
{"id":"postplayhouse.com-fjd","title":"Error: Unable to preload CSS","description":"**Sentry Issues:** JAVASCRIPT-SVELTEKIT-8B, 9P, 9W, 9X, 9Y, A5\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-8B\n**Occurrences:** 152+ across multiple issue variants\n**First Seen:** 2025-05-23\n\n**Error:** Error: Unable to preload CSS for https://postplayhouse.com/\\_app/immutable/assets/1.B8231T6f.css\n**Affected pages:** Various (/, /who/*, /calendar/*, /plan-your-visit/, etc.)\n**Affected browsers:** Chrome, various\n\n**Likely Cause:** CSS preload failures occur when:\n- Deployment changes file hashes but user has cached HTML\n- CDN/network issues preventing CSS delivery\n- Browser extensions blocking resource loading\n- CORS or mixed content issues\n\nThis is a common SvelteKit issue related to cache invalidation between deployments.\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-21T22:54:17.537447-05:00","updated_at":"2025-12-21T23:01:28.415385-05:00","closed_at":"2025-12-21T23:01:28.415385-05:00","close_reason":"CSS cache invalidation between deployments - not a code bug, same root cause as module import failures","labels":["bug"]}
{"id":"postplayhouse.com-k6z","title":"Test infrastructure for external services","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T14:13:02.824516-05:00","created_by":"dondenton","updated_at":"2026-01-11T14:13:02.824516-05:00"}
{"id":"postplayhouse.com-l4v","title":"ReferenceError: site is not defined","description":"**Sentry Issue:** JAVASCRIPT-SVELTEKIT-A3\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-A3\n**Occurrences:** 1+\n**First Seen:** 2025-12-15\n\n**Error:** ReferenceError: site is not defined\n**Culprit:** GET /(app)/data/productions/[year].json\n\n**Likely Cause:** A variable named 'site' is referenced but not defined in the productions data endpoint. Check the page.svelte.js or server files for missing imports or variable definitions.\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-21T22:54:15.62778-05:00","updated_at":"2025-12-21T23:00:49.820805-05:00","closed_at":"2025-12-21T23:00:49.820805-05:00","close_reason":"One-time build error from Dec 15 - never recurred, code is correct","labels":["bug"]}
{"id":"postplayhouse.com-pb0","title":"Admin UI and image processing","description":"Create /admin/bios route with passphrase-based admin auth. List pending bios with preview. Approve button processes image with Sharp, uploads optimized to B2. Reject button deletes from Blobs and sends Basecamp message. Done Approving button purges CDN cache and warms cache.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T00:05:59.949427-05:00","updated_at":"2026-01-11T00:32:27.701973-05:00","closed_at":"2026-01-11T00:32:27.701973-05:00","close_reason":"Broken down into detailed sub-issues: chd (B2 utils), pd5 (Sharp), 8a0 (image proxy), 9qn (list endpoint), a1q (approve endpoint), aad (reject endpoint), x1l (cache purge), cr8 (admin UI), bqq (tests)","dependencies":[{"issue_id":"postplayhouse.com-pb0","depends_on_id":"postplayhouse.com-wb6","type":"parent-child","created_at":"2025-12-22T00:06:18.009337-05:00","created_by":"daemon"},{"issue_id":"postplayhouse.com-pb0","depends_on_id":"postplayhouse.com-5p9","type":"blocks","created_at":"2025-12-22T00:06:23.968861-05:00","created_by":"daemon"}]}
{"id":"postplayhouse.com-pd5","title":"Create Sharp image processing module","description":"## Goal\nCreate a server-side module that uses Sharp to optimize headshot images for web display during the admin bio approval process.\n\n## Background\nWhen admins approve a bio submission, the original uploaded image needs to be processed:\n- Resized to max 800x800 pixels (maintaining aspect ratio, no enlargement)\n- Converted to progressive JPEG with quality 80\n- Uploaded to B2 storage in the optimized/ folder\n\nThis processed image is what gets served to website visitors.\n\n## Implementation\n\n### Create `src/lib/server/imageProcessing.ts`\n\n```typescript\nimport sharp from \"sharp\"\n\n/**\n * Process a headshot image for web display\n * - Resize to max 800x800 (fit inside, no enlargement)\n * - Convert to progressive JPEG with quality 80\n */\nexport async function processHeadshotImage(imageBuffer: Buffer): Promise\u003cBuffer\u003e {\n  return sharp(imageBuffer)\n    .resize(800, 800, {\n      fit: \"inside\",\n      withoutEnlargement: true,\n    })\n    .jpeg({\n      quality: 80,\n      progressive: true,\n    })\n    .toBuffer()\n}\n\n/**\n * Helper to convert a name to kebab-case for filenames\n */\nexport function toKebabCase(str: string): string {\n  return str\n    .trim()\n    .toLowerCase()\n    .replace(/[^a-z]+/gi, \"-\")\n}\n\n/**\n * Generate the optimized image filename for B2 storage\n */\nexport function getOptimizedImagePath(season: number, firstName: string, lastName: string): string {\n  const kebabName = toKebabCase(\\`\\${firstName} \\${lastName}\\`)\n  return \\`optimized/\\${season}/\\${kebabName}.jpg\\`\n}\n```\n\n## Dependencies\n- `sharp` package (already installed: ^0.34.5 in package.json)\n- `src/lib/server/b2.ts` for uploading processed images (created in separate issue)\n\n## Usage Example\n```typescript\nimport { processHeadshotImage, getOptimizedImagePath } from \"$lib/server/imageProcessing\"\nimport { downloadFromB2, uploadBufferToB2 } from \"$lib/server/b2\"\n\n// Download original image\nconst originalBuffer = await downloadFromB2(bio.originalImageUrl)\n\n// Process with Sharp\nconst optimizedBuffer = await processHeadshotImage(originalBuffer)\n\n// Upload optimized version\nconst optimizedPath = getOptimizedImagePath(season, bio.firstName, bio.lastName)\nawait uploadBufferToB2(optimizedBuffer, optimizedPath, \"image/jpeg\")\n```\n\n## Verification\n1. Write a simple test script or use Node REPL to verify Sharp processing:\n   ```bash\n   node -e \"\n     const sharp = require('sharp');\n     const fs = require('fs');\n     const input = fs.readFileSync('test-image.jpg');\n     sharp(input)\n       .resize(800, 800, { fit: 'inside', withoutEnlargement: true })\n       .jpeg({ quality: 80, progressive: true })\n       .toBuffer()\n       .then(buf =\u003e {\n         fs.writeFileSync('test-output.jpg', buf);\n         console.log('Original:', input.length, 'bytes');\n         console.log('Optimized:', buf.length, 'bytes');\n       });\n   \"\n   ```\n2. Verify output is a valid JPEG under 800x800","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T00:21:35.794378-05:00","created_by":"dondenton","updated_at":"2026-01-11T00:21:35.794378-05:00","dependencies":[{"issue_id":"postplayhouse.com-pd5","depends_on_id":"postplayhouse.com-chd","type":"blocks","created_at":"2026-01-11T00:30:49.207897-05:00","created_by":"dondenton"}]}
{"id":"postplayhouse.com-uop","title":"Error: 500 during SvelteKit prerender","description":"**Sentry Issue:** JAVASCRIPT-SVELTEKIT-9Z\n**URL:** https://post-playhouse.sentry.io/issues/JAVASCRIPT-SVELTEKIT-9Z\n**Occurrences:** 8\n**First Seen:** 2025-12-09\n**Last Seen:** 2025-12-15\n\n**Error:** Error: 500 /plan-your-visit/ (linked from /plan-your-visit)\n**Culprit:** SvelteKit prerender.js\n\n**Stacktrace:** Error occurs in @sveltejs/kit prerender.js when saving prerendered pages - indicates a server-side error during static site generation.\n\n**Related Issues:** Likely related to JAVASCRIPT-SVELTEKIT-A4 (JSON parse error) which occurs on the same /plan-your-visit page.\n\n**Seer Analysis:** Not available (no budget)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-21T22:54:13.34742-05:00","updated_at":"2025-12-21T22:58:07.897329-05:00","closed_at":"2025-12-21T22:58:07.897329-05:00","close_reason":"Fixed by commit 3a8b772c on Dec 15 - prerender now succeeds (was caused by JSON parse error in plan-your-visit)","labels":["bug"]}
{"id":"postplayhouse.com-v1t","title":"Page SSR conversion","description":"Modify /who/[year]/+page.ts to route current season to SSR endpoint. Modify /program-bios/+page.ts to use SSR endpoint. Keep historical years prerendered.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T00:05:59.083016-05:00","updated_at":"2025-12-22T23:29:12.712262-05:00","closed_at":"2025-12-22T23:29:12.712262-05:00","close_reason":"Routed /who/[year] and /program-bios to use SSR endpoint for current season. Historical years remain prerendered.","dependencies":[{"issue_id":"postplayhouse.com-v1t","depends_on_id":"postplayhouse.com-wb6","type":"parent-child","created_at":"2025-12-22T00:06:17.461578-05:00","created_by":"daemon"},{"issue_id":"postplayhouse.com-v1t","depends_on_id":"postplayhouse.com-6r0","type":"blocks","created_at":"2025-12-22T00:06:23.412374-05:00","created_by":"daemon"}]}
{"id":"postplayhouse.com-wb6","title":"Bio Submission \u0026 Approval System","description":"Replace GitHub PR-based bio submission with Netlify Blobs storage, in-site admin approval UI, SSR for current season pages, and CDN cache purging for instant updates.\n\n## Architecture Overview\n\n```\nUser submits bio → Netlify Blobs (metadata) + B2 (original image)\n                         ↓\nAdmin approves via /admin/bios → Sharp processes image → stores optimized in B2\n                         ↓\nAdmin clicks \"Done Approving\" → CDN cache purged + cache warmed\n                         ↓\nEnd of season: Export approved bios to YAML → commit to Git\n```\n\n## Key Changes\n\n### 1. Pending Bio Storage\n- **Bio metadata**: Netlify Blobs (JSON) - `pending-bios` store\n  - `{season}/pending/{position}` - awaiting approval\n  - `{season}/approved/{position}` - approved, visible on site\n- **Images in B2**:\n  - `originals/{season}/{name}.jpg` - untouched upload (for archives)\n  - `optimized/{season}/{name}.jpg` - processed on approval (served to users)\n\n### 2. Image Processing (on approval)\nWhen admin approves a bio:\n1. Fetch original image from B2\n2. Use Sharp to resize/compress (800x800 max, quality 80, progressive JPEG)\n3. Upload optimized version to B2\n4. Bio references the optimized URL\n\n### 3. SSR for Current Season Pages\nConvert these pages from prerendered to SSR:\n- `/who/{currentYear}` - only current season, historical years stay prerendered\n- `/program-bios` - always shows current season\n\nCache headers:\n```\nCache-Control: public, max-age=0\nNetlify-CDN-Cache-Control: public, max-age=86400, stale-while-revalidate=3600\nCache-Tag: people-2026,bios\n```\n\n### 4. Admin UI \u0026 Auth\nNew route `/admin/bios`:\n- **Auth**: Reuse existing passphrases - flag certain positions as admins (e.g., positions 1-4)\n- Passphrase identifies who approved each bio\n- Lists pending bios with preview\n- Approve button (no reject storage - just Basecamp message)\n- **Batch workflow**: Approve multiple, then click \"Done Approving\" to purge CDN cache once and warm cache\n\n### 5. Rejection Flow\nNo rejection storage. When admin rejects:\n1. Delete pending bio from Blobs\n2. Send Basecamp message: \"{admin name} rejected {submitter name}'s bio. Discussion should happen here.\"\n\n### 6. Submission Flow\n1. User fills form (same UI)\n2. Backend writes bio JSON to Netlify Blobs\n3. Backend uploads original image to B2 `originals/` folder\n4. Basecamp notification sent\n5. Admin reviews at `/admin/bios`\n\n### 7. Export to YAML\nAdmin endpoint `/api/admin/export-bios?year=2026` generates YAML for archival.\n\n## Files to Create\n\n| File | Purpose |\n|------|---------|\n| `src/lib/server/blobs.ts` | Netlify Blobs utilities |\n| `src/lib/server/image-processing.ts` | Sharp utilities for image optimization |\n| `src/routes/api/people/[year].json/+server.ts` | SSR data endpoint merging YAML + Blobs |\n| `src/routes/api/bio-submission/submit/+server.ts` | New Blobs-based submission |\n| `src/routes/(app)/admin/bios/+page.svelte` | Admin UI |\n| `src/routes/(app)/admin/bios/+page.server.ts` | Admin data loading + auth |\n| `src/routes/api/admin/approve-bio/+server.ts` | Approve endpoint |\n| `src/routes/api/admin/reject-bio/+server.ts` | Reject endpoint |\n| `src/routes/api/admin/finish-approvals/+server.ts` | Cache purge + warming |\n| `src/routes/api/admin/export-bios/+server.ts` | YAML export |\n\n## Files to Modify\n\n| File | Changes |\n|------|---------|\n| `src/routes/(app)/who/[year]/+page.ts` | Use SSR endpoint for current season |\n| `src/routes/(app)/program-bios/+page.ts` | Use SSR endpoint |\n| `src/routes/(app)/bio-submission/+page.svelte` | Call new submission endpoint |\n| `src/routes/api/bio-submission/passphraseHelpers.ts` | Add `isAdmin(position)` helper |\n| `vite.config.ts` | Add `@netlify/vite-plugin` for local Blobs dev |\n| `package.json` | Add `@netlify/blobs`, `@netlify/functions` |\n\n## Data Schema (Blobs)\n\n```typescript\ninterface PendingBio {\n  position: number\n  firstName: string\n  lastName: string\n  location: string\n  email: string\n  bio: string\n  programBio?: string\n  staffPositions?: string[]\n  productionPositions?: Record\u003cstring, string[]\u003e\n  roles?: Record\u003cstring, string[]\u003e\n  originalImageUrl: string   // B2 originals/ URL\n  optimizedImageUrl?: string // B2 optimized/ URL (set on approval)\n  imageYear: number\n  submittedAt: string\n  approvedAt?: string\n  approvedBy?: string  // Admin name from passphrase position\n}\n```\n\n## Environment Variables\n\n**New:**\n- `ADMIN_PASSPHRASE_POSITIONS` - Comma-separated admin positions (e.g., \"1,2,3,4\")\n\n**Existing (keep):**\n- `B2_APPLICATION_KEY_ID`, `B2_APPLICATION_KEY`, `B2_BUCKET_ID`\n- `INDIVIDUAL_PASSPHRASES_LIST`\n- `BASECAMP_BIO_BOT_INTEGRATION_KEY`\n\n**Can remove later:**\n- `GITHUB_ACCESS_TOKEN`","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-22T00:05:41.344859-05:00","updated_at":"2025-12-22T00:13:56.218535-05:00"}
{"id":"postplayhouse.com-x1l","title":"Create cache purge API endpoint","description":"## Goal\nCreate an API endpoint that purges the CDN cache and warms SSR pages after bio approvals are complete.\n\n## Background\nWhen admins finish approving bios, they click \"Done Approving\" which:\n1. Purges the Netlify CDN cache for pages tagged with \"bios\"\n2. Warms the cache by fetching the SSR pages\n3. This ensures visitors immediately see the updated bios\n\nThe SSR pages use Cache-Tag headers (`people-{year},bios`) that enable selective cache invalidation.\n\n## Implementation\n\n### Create `src/routes/api/admin/bios/purge-cache/+server.ts`\n\n```typescript\nimport { json, error } from \"@sveltejs/kit\"\nimport { individualPassphraseDetails, isAdmin } from \"$routes/api/bio-submission/passphraseHelpers\"\nimport { env } from \"$env/dynamic/private\"\nimport * as site from \"$data/site\"\n\nexport const POST = async ({ request, fetch }) =\u003e {\n  // Validate admin access\n  const { correct, position } = individualPassphraseDetails(request)\n  \n  if (!correct) {\n    return error(403, { message: \"Invalid passphrase\" })\n  }\n  \n  if (!isAdmin(position)) {\n    return error(403, { message: \"Admin access required\" })\n  }\n\n  const netlifyToken = env[\"NETLIFY_API_TOKEN\"]\n  const siteId = env[\"NETLIFY_SITE_ID\"]\n\n  if (!netlifyToken || !siteId) {\n    console.error(\"Missing NETLIFY_API_TOKEN or NETLIFY_SITE_ID\")\n    return error(500, { message: \"Cache purge not configured\" })\n  }\n\n  const results = {\n    purge: { success: false, error: null as string | null },\n    warm: { success: false, pages: [] as string[], errors: [] as string[] },\n  }\n\n  // Step 1: Purge Netlify CDN cache by tag\n  try {\n    const purgeResponse = await fetch(\"https://api.netlify.com/api/v1/purge\", {\n      method: \"POST\",\n      headers: {\n        Authorization: \\`Bearer \\${netlifyToken}\\`,\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        site_id: siteId,\n        cache_tags: [\"bios\"],\n      }),\n    })\n\n    if (!purgeResponse.ok) {\n      const errorText = await purgeResponse.text()\n      throw new Error(\\`Netlify API error: \\${purgeResponse.status} - \\${errorText}\\`)\n    }\n\n    results.purge.success = true\n  } catch (err) {\n    console.error(\"Cache purge failed:\", err)\n    results.purge.error = err instanceof Error ? err.message : \"Unknown error\"\n  }\n\n  // Step 2: Warm cache by fetching SSR pages\n  // Use the public site URL (from env or construct from request)\n  const baseUrl = env[\"PUBLIC_BUILD_URL\"] || \"https://postplayhouse.com\"\n  const pagesToWarm = [\n    \\`/who/\\${site.season}/\\`,\n    \"/program-bios/\",\n    \\`/api/people/\\${site.season}.json\\`,\n  ]\n\n  const warmResults = await Promise.allSettled(\n    pagesToWarm.map(async (pagePath) =\u003e {\n      const url = \\`\\${baseUrl}\\${pagePath}\\`\n      const response = await fetch(url, {\n        // Add cache-busting header to ensure fresh fetch\n        headers: { \"Cache-Control\": \"no-cache\" },\n      })\n      if (!response.ok) {\n        throw new Error(\\`\\${response.status}\\`)\n      }\n      return pagePath\n    })\n  )\n\n  warmResults.forEach((result, index) =\u003e {\n    if (result.status === \"fulfilled\") {\n      results.warm.pages.push(pagesToWarm[index])\n    } else {\n      results.warm.errors.push(\\`\\${pagesToWarm[index]}: \\${result.reason}\\`)\n    }\n  })\n\n  results.warm.success = results.warm.errors.length === 0\n\n  // Return success even if warming had issues (purge is the critical part)\n  const overallSuccess = results.purge.success\n\n  return json({\n    success: overallSuccess,\n    message: overallSuccess\n      ? \"Cache purged successfully\"\n      : \"Cache purge failed\",\n    details: results,\n  })\n}\n```\n\n## Request Format\n```typescript\nPOST /api/admin/bios/purge-cache\nHeaders: { Authorization: \"admin_passphrase\" }\nBody: (none required)\n```\n\n## Response Format\n```typescript\n{\n  success: boolean,\n  message: string,\n  details: {\n    purge: {\n      success: boolean,\n      error: string | null\n    },\n    warm: {\n      success: boolean,\n      pages: string[],      // Successfully warmed pages\n      errors: string[]      // Failed warm attempts\n    }\n  }\n}\n```\n\n## Environment Variables Required\nAdd to `.env.example` and Netlify env config:\n\n```\n# Netlify API for cache purging\nNETLIFY_API_TOKEN=nfp_xxxxxxxxxxxx\nNETLIFY_SITE_ID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n```\n\n### How to Get These Values:\n1. **NETLIFY_API_TOKEN**: \n   - Go to Netlify User Settings \u003e Applications \u003e Personal Access Tokens\n   - Create a new token with appropriate scope\n2. **NETLIFY_SITE_ID**: \n   - Go to Site Settings \u003e General \u003e Site ID\n   - Or use `netlify sites:list` CLI command\n\n## Netlify Purge API Notes\n- Endpoint: POST https://api.netlify.com/api/v1/purge\n- Requires Bearer token authentication\n- Body: `{ site_id: string, cache_tags: string[] }`\n- Purges all cached responses with matching Cache-Tag headers\n- Our pages use: `Cache-Tag: people-{year},bios`\n\n## Pages Warmed\n1. `/who/{season}/` - Current season people page\n2. `/program-bios/` - Program bios page\n3. `/api/people/{season}.json` - Data API endpoint\n\n## Dependencies\n- `src/routes/api/bio-submission/passphraseHelpers.ts` - admin authentication\n- `src/data/site.ts` - current season for constructing URLs\n\n## Verification\n1. Ensure NETLIFY_API_TOKEN and NETLIFY_SITE_ID are set\n2. Approve a bio through the admin flow\n3. Call purge endpoint:\n   ```bash\n   curl -X POST \\\n     -H \"Authorization: admin_passphrase\" \\\n     http://localhost:5173/api/admin/bios/purge-cache\n   ```\n4. Verify response shows purge success\n5. Check Netlify dashboard for purge event (optional)\n6. Visit /who/2026/ and verify content is fresh","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-11T00:28:09.034489-05:00","created_by":"dondenton","updated_at":"2026-01-11T00:28:09.034489-05:00","dependencies":[{"issue_id":"postplayhouse.com-x1l","depends_on_id":"postplayhouse.com-k6z","type":"blocks","created_at":"2026-01-11T14:13:15.799695-05:00","created_by":"dondenton"}]}
